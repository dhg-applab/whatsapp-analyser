import emoji
import pandas as pd
import re
from pathlib import Path
from typing import Dict, List, Match, Tuple
from MessageType import MessageType


class WhatsAppExtractor:
    """A class to extract WhatsApp chat data."""

    AUTOGENERATED_MESSAGES = {
        'Messages and calls are end-to-end encrypted. No one outside of this chat, not even WhatsApp, can read or listen to them.',
        'Messages to yourself are end-to-end encrypted. No one outside of this chat, not even WhatsApp, can read or listen to them.',
        'Missed voice call.',
        'Missed video call.',
        'You deleted this message.',
        'This message was deleted.',
        'You changed this group\'s icon.',
        'You changed the group description.'
    }

    NONPRINTABLE_CHARACTERS = '\u200E\u202A\u202C'
    ATTACHMENT_START_INDEX = 11
    ATTACHMENT_END_INDEX = -1
    FILE_PATTERN = re.compile(r'^(.*) <attached: (.*)>$')
    LOCATION_PATTERN = re.compile(r'^(.*?) \((.*?)\):\shttps://maps\.google\.com/\?q=(-?\d+\.\d+),(-?\d+\.\d+)$')
    POLL_PATTERN = re.compile(r'^POLL:\n(.+)\n((?:OPTION: .+ \(\d+ vote[s]?\)\n?){2,})$', re.MULTILINE)

    def __init__(self, include_emojis: bool = True, min_message_time: str = None):
        """Initialise WhatsAppExtractor instance."""
        self.include_emojis = include_emojis
        self.min_message_time = pd.to_datetime(min_message_time, format='%d.%m.%y') if min_message_time else None

    def extract_chat_data(self, chat_data_path: str) -> pd.DataFrame:
        """Extract and preprocess chat data."""
        return self._parse_messages(chat_data_path)

    @staticmethod
    def _read_chat_file(chat_file_path: str) -> List[str]:
        """Read the chat messages one by one."""
        with open(chat_file_path, 'r', encoding='utf-8') as file:
            content = file.read()
            content = WhatsAppExtractor._filter_nonprintable_characters(content)
            lines = content.split('\n')
            message_lines = []
            for line in lines:
                if line.startswith('[') and message_lines:
                    yield '\n'.join(message_lines)
                    message_lines.clear()
                message_lines.append(line)
            if message_lines:
                yield '\n'.join(message_lines)

    @staticmethod
    def _filter_autogenerated_messages(message: str) -> bool:
        """Filter autogenerated messages."""
        return message not in WhatsAppExtractor.AUTOGENERATED_MESSAGES

    @staticmethod
    def _filter_nonprintable_characters(text: str) -> str:
        """Filter non-printable characters."""
        return re.sub(f'[{WhatsAppExtractor.NONPRINTABLE_CHARACTERS}]', '', text)

    def _parse_messages(self, chat_data_path: str) -> pd.DataFrame:
        """Parse chat messages from the chat file."""
        try:
            chat_file_path = Path(chat_data_path, '_chat.txt').resolve()
            messages = []
            for line in self._read_chat_file(str(chat_file_path)):
                timestamp, user, message = self._parse_line(line)
                preprocessed_message, message_type = self._preprocess_message(message)
                if self._is_valid_message(timestamp, message, message_type):
                    messages.append({
                        'datetime': timestamp,
                        'user': user,
                        'message': preprocessed_message,
                        'type': message_type
                    })
            return pd.DataFrame(messages)
        except (ValueError, IndexError) as e:
            raise ValueError(f'Failed to parse chat file: {str(e)}')

    def _is_valid_message(self, timestamp: pd.Timestamp, message: str, message_type: MessageType) -> bool:
        """Check if a message is valid."""
        return (not self.min_message_time or timestamp >= self.min_message_time) and (
                message_type != MessageType.TEXT or WhatsAppExtractor._filter_autogenerated_messages(message))

    @staticmethod
    def _parse_line(line: str) -> Tuple[pd.Timestamp, str, str]:
        """Extract timestamp, user, and message from a line."""
        try:
            timestamp_end_index = line.find('] ')
            timestamp = pd.to_datetime(line[1:timestamp_end_index], format='%d.%m.%y, %H:%M:%S')
            user_end_index = line.find(': ', timestamp_end_index)
            user = line[timestamp_end_index + 2:user_end_index]
            message = line[user_end_index + 2:].strip()
            return timestamp, user, message
        except ValueError as e:
            raise ValueError(f'Failed to parse line: {line}\n{str(e)}')

    def _preprocess_message(self, message: str) -> Tuple[str, MessageType]:
        """Preprocess the message."""
        if message.startswith('<attached: ') and message.endswith('>'):
            message_type, message = WhatsAppExtractor._parse_attachment(message)
        elif message == 'image omitted':
            message_type = MessageType.VIEW_ONCE_PHOTO
        elif message == 'video omitted':
            message_type = MessageType.VIEW_ONCE_VIDEO
        elif file_match := WhatsAppExtractor.FILE_PATTERN.match(message):
            message_type, message = MessageType.FILE, WhatsAppExtractor._parse_file(file_match)
        elif location_match := WhatsAppExtractor.LOCATION_PATTERN.match(message):
            message_type, message = MessageType.LOCATION, WhatsAppExtractor._parse_location(location_match)
        elif poll_match := re.match(WhatsAppExtractor.POLL_PATTERN, message):
            message_type, message = MessageType.POLL, WhatsAppExtractor._parse_poll(poll_match)
        else:
            message_type = MessageType.TEXT

        if message_type == MessageType.TEXT:
            return WhatsAppExtractor._process_emojis(message, self.include_emojis), message_type
        else:
            return message, message_type

    @staticmethod
    def _process_emojis(message: str, include_emojis: bool) -> str:
        """Process emojis in a message."""
        if include_emojis:
            return message
        else:
            return emoji.replace_emoji(message, replace='')

    @staticmethod
    def _parse_attachment(message: str) -> Tuple[MessageType, str]:
        """Parse attachment information from a message."""
        attachment = message[WhatsAppExtractor.ATTACHMENT_START_INDEX:WhatsAppExtractor.ATTACHMENT_END_INDEX]
        if attachment.endswith('.webp'):
            message_type = MessageType.STICKER
        elif attachment.endswith(('.jpg', '.jpeg', '.png')):
            message_type = MessageType.PHOTO
        elif attachment.endswith('.opus'):
            message_type = MessageType.VOICE_MESSAGE
        elif attachment.endswith(('.mp4', '.mov')):
            message_type = MessageType.VIDEO
        elif attachment.endswith('.vcf'):
            message_type = MessageType.CONTACT
        else:
            raise ValueError(f'Unknown attachment type: {attachment}')
        return message_type, attachment

    @staticmethod
    def _parse_file(file_match: Match[str]) -> Dict[str, str]:
        """Parse file information from a message."""
        filename = file_match.group(1)
        file_url = file_match.group(2)
        return {'filename': filename, 'file_url': file_url}

    @staticmethod
    def _parse_location(location_match: Match[str]) -> Dict[str, str]:
        """Parse location information from a message."""
        location, city, latitude, longitude = location_match.groups()
        return {'location': location, 'city': city, 'latitude': latitude, 'longitude': longitude}

    @staticmethod
    def _parse_poll(poll_match: Match[str]) -> Dict[str, List[Dict[str, int]]]:
        """Parse poll information from a message."""
        question = poll_match.group(1)
        options = re.findall(r'OPTION: (.+) \((\d+) votes?\)', poll_match.group(2))
        poll = {
            'question': question,
            'options': [{'option': option, 'votes': int(votes)} for option, votes in options]
        }
        return poll

    def set_include_emojis(self, include_emojis: bool):
        """Set the value of include_emojis."""
        self.include_emojis = include_emojis

    def set_min_message_time(self, min_message_time: str):
        """Set the value of min_message_time."""
        self.min_message_time = pd.to_datetime(min_message_time, format='%d.%m.%y') if min_message_time else None
